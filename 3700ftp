#!/usr/bin/env python3
import socket
import argparse
from urllib.parse import urlparse
import os


def parse_pasv_response(response):
    parts = response.split()
    code = int(parts[0])

    if code // 100 == 2:
        try:
            # Find the opening parenthesis in the response
            opening_paren_index = response.index('(')
            # Extract the comma-separated values inside the parentheses
            host_port_str = response[opening_paren_index + 1: response.index(')', opening_paren_index)]
            host, port_str = host_port_str.split(',')[:4], host_port_str.split(',')[4:]
            host = '.'.join(host)
            port = int(port_str[0]) * 256 + int(port_str[1])
            return host, port
        except (ValueError, IndexError):
            print("Failed to parse PASV response")
    return None, None


class FTPClient:
    def __init__(self, server_url, username, password):
        self.server_url = urlparse(server_url)
        self.username = username
        self.password = password
        self.control_socket = None
        self.data_socket = None

    def connect(self):
        if not self.server_url.hostname:
            print("Invalid server URL")
            return

        self.control_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.control_socket.connect((self.server_url.hostname, self.server_url.port or 21))
        self.receive_response()

    def login(self):
        if not self.username:
            raise ValueError("Please specify a username for login")

        self.send_command(f"USER {self.username}")
        self.receive_response()

        if self.password:
            self.send_command(f"PASS {self.password}")
            self.receive_response()

    def send_command(self, command):
        self.control_socket.send((command + '\r\n').encode())

    def receive_response(self):
        data = self.control_socket.recv(4096).decode()
        print(data)
        return data

    def pasv(self):
        self.send_command("PASV")
        response = self.receive_response()
        return parse_pasv_response(response)

    def ls(self, path):
        host, port = self.pasv()
        if host and port:
            self.send_command(f"LIST {path}")

            data_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            data_socket.connect((host, port))

            data = b""
            while True:
                chunk = data_socket.recv(4096)
                if not chunk:
                    break
                data += chunk

            print(data.decode())

            data_socket.close()
            self.receive_response()

    def mkdir(self, path):
        self.send_command(f"MKD {path}")
        self.receive_response()

    def rm(self, path):
        self.send_command(f"DELE {path}")
        self.receive_response()

    def rmdir(self, path):
        self.send_command(f"RMD {path}")
        self.receive_response()

    def cp(self, source, destination):
        # Parse the FTP URLs of the source and destination
        source_url = urlparse(source)
        dest_url = urlparse(destination)

        # Check for valid combinations of source and destination
        if (not source_url.scheme or source_url.scheme == 'file') and dest_url.scheme == 'ftp':
            # Copy from local to remote
            self.copy_local_to_remote(source, destination)
        elif source_url.scheme == 'ftp' and (not dest_url.scheme or dest_url.scheme == 'file'):
            # Copy from remote to local
            self.copy_remote_to_local(source, destination)
        else:
            print("Invalid combination of source and destination")

    def copy_local_to_remote(self, source, destination):
        with open(source, 'rb') as file:
            self.send_command(f"STOR {destination}")
            host, port = self.pasv()
            if host and port:
                data_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                data_socket.connect((host, port))
                while True:
                    chunk = file.read(4096)
                    if not chunk:
                        break
                    data_socket.sendall(chunk)
                data_socket.close()

    def copy_remote_to_local(self, source, destination):
        # Parse the FTP URL of the source
        source_url = urlparse(source)

        # Open the destination file in binary write mode
        with open(destination, 'wb') as local_file:
            # Connect to the FTP server
            self.connect()

            # Send USER and PASS commands to log in
            self.send_command(f"USER {source_url.username}")
            self.send_command(f"PASS {source_url.password}")

            # Set the data transfer mode to binary
            self.send_command("TYPE I")

            # Set the connection to passive mode and get data connection details
            host, port = self.pasv()

            # Send the RETR command to initiate the data transfer
            self.send_command(f"RETR {source_url.path}")

            # Connect to the data socket and receive the file data
            data_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            data_socket.connect((host, port))
            while True:
                chunk = data_socket.recv(4096)
                if not chunk:
                    break
                local_file.write(chunk)

            # Close the data socket
            data_socket.close()

            # Receive the response after the data transfer
            response = self.receive_response()
            print(response)

    def mv(self, source, destination):
        # Parse the FTP URLs of the source and destination
        source_url = urlparse(source)
        dest_url = urlparse(destination)

        # Connect to the FTP server
        self.connect()

        # Send USER and PASS commands to log in
        self.send_command(f"USER {source_url.username}")
        self.send_command(f"PASS {source_url.password}")

        # Send TYPE I command to set the data transfer mode to binary
        self.send_command("TYPE I")

        # Set the connection to passive mode and get data connection details
        host, port = self.pasv()

        # Send the RETR command to initiate the data transfer for the source file
        self.send_command(f"RETR {source_url.path}")

        # Connect to the data socket and receive the file data
        data_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        data_socket.connect((host, port))
        data = b""
        while True:
            chunk = data_socket.recv(4096)
            if not chunk:
                break
            data += chunk

        # Close the data socket
        data_socket.close()

        # Send the STOR command to initiate the data transfer for the destination file
        self.send_command(f"STOR {dest_url.path}")

        # Connect to the data socket and send the file data
        data_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        data_socket.connect((host, port))
        data_socket.sendall(data)

        # Close the data socket
        data_socket.close()

        # Receive the response after the data transfer
        response = self.receive_response()
        print(response)


def parse_args():
    parser = argparse.ArgumentParser(description='FTP client for basic operations')
    parser.add_argument('operation', choices=['ls', 'mkdir', 'rm', 'rmdir', 'cp', 'mv'],
                        help='Operation to execute')
    parser.add_argument('param1', help='First parameter (local or FTP path)')
    parser.add_argument('param2', nargs='?', default='', help='Second parameter (local or FTP path)')
    return parser.parse_args()


def main():
    args = parse_args()
    url_parts = urlparse(args.param1)
    username = 'jonahc'
    password = '1b10da1e033405616a318b5edcb4ca077919f67f35fd99f48fcf34e2aa5e96d2'
    server_url = f"{url_parts.scheme}://{url_parts.hostname}/"
    ftp_client = FTPClient(server_url, username, password)
    ftp_client.connect()
    ftp_client.login()

    if args.operation == 'ls':
        ftp_client.ls(args.param1)
    elif args.operation == 'mkdir':
        ftp_client.mkdir(args.param1)
    elif args.operation == 'rm':
        ftp_client.rm(args.param1)
    elif args.operation == 'rmdir':
        ftp_client.rmdir(args.param1)
    elif args.operation == 'cp':
        ftp_client.cp(args.param1, args.param2)
    elif args.operation == 'mv':
        ftp_client.mv(args.param1, args.param2)


if __name__ == "__main__":
    main()
